
stk500boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  000074c8  0000053c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004c8  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000028  00000000  00000000  00000550  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000002a  00000000  00000000  00000578  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004bf  00000000  00000000  000005a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000001af  00000000  00000000  00000a61  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000007a0  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000040  00000000  00000000  000013b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000020a  00000000  00000000  000013f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000808  00000000  00000000  000015fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubtypes 00000046  00000000  00000000  00001e02  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  00001e48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__jumpMain>:
 * to reduce the code size, we need to provide our own initialization
 */
void __jumpMain     (void) __attribute__ ((naked)) __attribute__ ((section (".init9")));

void __jumpMain(void)
{    
    7000:	8f ef       	ldi	r24, 0xFF	; 255
	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );

	/* init stack here, bug WinAVR 20071221 does not init stack based on __stack */
	asm volatile ("ldi r24,%0":: "M" (RAMEND & 0xFF));
	asm volatile ("ldi r25,%0":: "M" (RAMEND >> 8));
    7002:	98 e0       	ldi	r25, 0x08	; 8
	asm volatile ("out __SP_H__,r25" ::);
    7004:	9e bf       	out	0x3e, r25	; 62
	asm volatile ("out __SP_L__,r24" ::);
    7006:	8d bf       	out	0x3d, r24	; 61

	asm volatile ( "clr __zero_reg__" );                       // GCC depends on register r1 set to 0
    7008:	11 24       	eor	r1, r1
	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );  // set SREG to 0
    700a:	1f be       	out	0x3f, r1	; 63
#ifndef REMOVE_PROG_PIN_PULLUP	 
	PROG_PORT |= (1<<PROG_PIN);		                           // Enable internal pullup
    700c:	5a 9a       	sbi	0x0b, 2	; 11
#endif    
	asm volatile ( "rjmp main");                               // jump to main()
    700e:	07 c0       	rjmp	.+14     	; 0x701e <main>

00007010 <sendchar>:
/*
 * send single byte to USART, wait until transmission is completed
 */
static void sendchar(char c)
{
	while((UCSR0A & (1<< UDRE0)) == 0) {};
    7010:	90 91 c0 00 	lds	r25, 0x00C0
    7014:	95 ff       	sbrs	r25, 5
    7016:	fc cf       	rjmp	.-8      	; 0x7010 <sendchar>
	UDR0=c;
    7018:	80 93 c6 00 	sts	0x00C6, r24
}
    701c:	08 95       	ret

0000701e <main>:
}


int main(void) __attribute__ ((OS_main));
int main(void)
{
    701e:	cd b7       	in	r28, 0x3d	; 61
    7020:	de b7       	in	r29, 0x3e	; 62
    7022:	c5 52       	subi	r28, 0x25	; 37
    7024:	d1 40       	sbci	r29, 0x01	; 1
    7026:	de bf       	out	0x3e, r29	; 62
    7028:	cd bf       	out	0x3d, r28	; 61
#define BAUD_ERROR ((BAUD_REAL*1000)/BAUD) // Fehler in Promille, 1000 = kein Fehler. // 1001,5625
#if ((BAUD_ERROR<990) || (BAUD_ERROR>1010))
#warning Systematischer Fehler der Baudrate grsser 1% und damit zu hoch!
#endif

	UBRR0H = UBRR_VAL >> 8;
    702a:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = UBRR_VAL & 0xFF;
    702e:	83 e0       	ldi	r24, 0x03	; 3
    7030:	80 93 c4 00 	sts	0x00C4, r24
	UART_CONTROL_REG   = (1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
    7034:	88 e1       	ldi	r24, 0x18	; 24
    7036:	80 93 c1 00 	sts	0x00C1, r24

	DDRD |= (1<<PIND5) |(1<<PIND6) |(1<<PIND7); // 3x led AUSGANG,
    703a:	8a b1       	in	r24, 0x0a	; 10
    703c:	80 6e       	ori	r24, 0xE0	; 224
    703e:	8a b9       	out	0x0a, r24	; 10
	PORTD |= (1<<PIND5); // 3x led AUSGANG,
    7040:	5d 9a       	sbi	0x0b, 5	; 11


	msgLength		=	11;
	msgBuffer[0] 	=	CMD_SIGN_ON;
    7042:	81 e0       	ldi	r24, 0x01	; 1
    7044:	89 83       	std	Y+1, r24	; 0x01
	msgBuffer[1] 	=	STATUS_CMD_OK;
    7046:	1a 82       	std	Y+2, r1	; 0x02
	msgBuffer[2] 	=	8;
    7048:	88 e0       	ldi	r24, 0x08	; 8
    704a:	8b 83       	std	Y+3, r24	; 0x03
	msgBuffer[3] 	=	'A';
    704c:	81 e4       	ldi	r24, 0x41	; 65
    704e:	8c 83       	std	Y+4, r24	; 0x04
	msgBuffer[4] 	=	'V';
    7050:	86 e5       	ldi	r24, 0x56	; 86
    7052:	8d 83       	std	Y+5, r24	; 0x05
	msgBuffer[5] 	=	'R';
    7054:	82 e5       	ldi	r24, 0x52	; 82
    7056:	8e 83       	std	Y+6, r24	; 0x06
	msgBuffer[6] 	=	'I';
    7058:	89 e4       	ldi	r24, 0x49	; 73
    705a:	8f 83       	std	Y+7, r24	; 0x07
	msgBuffer[7] 	=	'S';
    705c:	83 e5       	ldi	r24, 0x53	; 83
    705e:	88 87       	std	Y+8, r24	; 0x08
	msgBuffer[8] 	=	'P';
    7060:	80 e5       	ldi	r24, 0x50	; 80
    7062:	89 87       	std	Y+9, r24	; 0x09
	msgBuffer[9] 	=	'_';
    7064:	8f e5       	ldi	r24, 0x5F	; 95
    7066:	8a 87       	std	Y+10, r24	; 0x0a
	msgBuffer[10]	=	'2';
    7068:	82 e3       	ldi	r24, 0x32	; 50
    706a:	8b 87       	std	Y+11, r24	; 0x0b
	sendchar(MESSAGE_START);
    706c:	8b e1       	ldi	r24, 0x1B	; 27
    706e:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	checksum	=	MESSAGE_START^0;

	sendchar(seqNum);
    7072:	80 e0       	ldi	r24, 0x00	; 0
    7074:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	checksum	^=	seqNum;

	c			=	((msgLength>>8)&0xFF);
	sendchar(c);
    7078:	80 e0       	ldi	r24, 0x00	; 0
    707a:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	checksum	^=	c;

	c			=	msgLength&0x00FF;
	sendchar(c);
    707e:	8b e0       	ldi	r24, 0x0B	; 11
    7080:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	checksum ^= c;

	sendchar(TOKEN);
    7084:	8e e0       	ldi	r24, 0x0E	; 14
    7086:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    708a:	9c e0       	ldi	r25, 0x0C	; 12
    708c:	e9 2e       	mov	r14, r25
    708e:	f1 2c       	mov	r15, r1
    7090:	ec 0e       	add	r14, r28
    7092:	fd 1e       	adc	r15, r29
	checksum ^= c;

	sendchar(TOKEN);
	checksum ^= TOKEN;

	p	=	msgBuffer;
    7094:	8e 01       	movw	r16, r28
    7096:	0f 5f       	subi	r16, 0xFF	; 255
    7098:	1f 4f       	sbci	r17, 0xFF	; 255
	c			=	msgLength&0x00FF;
	sendchar(c);
	checksum ^= c;

	sendchar(TOKEN);
	checksum ^= TOKEN;
    709a:	8e e1       	ldi	r24, 0x1E	; 30
    709c:	58 2e       	mov	r5, r24

	p	=	msgBuffer;
	while ( msgLength )
	{
		c	=	*p++;
    709e:	f8 01       	movw	r30, r16
    70a0:	d1 90       	ld	r13, Z+
    70a2:	8f 01       	movw	r16, r30
		sendchar(c);
    70a4:	8d 2d       	mov	r24, r13
    70a6:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
		checksum ^=c;
    70aa:	5d 24       	eor	r5, r13

	sendchar(TOKEN);
	checksum ^= TOKEN;

	p	=	msgBuffer;
	while ( msgLength )
    70ac:	0e 15       	cp	r16, r14
    70ae:	1f 05       	cpc	r17, r15
    70b0:	b1 f7       	brne	.-20     	; 0x709e <main+0x80>
		c	=	*p++;
		sendchar(c);
		checksum ^=c;
		msgLength--;
	}
	sendchar(checksum);
    70b2:	85 2d       	mov	r24, r5
    70b4:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
	seqNum++;
	PORTD |= (1<<PIND6); // 3x led AUSGANG,
    70b8:	5e 9a       	sbi	0x0b, 6	; 11
    70ba:	14 c0       	rjmp	.+40     	; 0x70e4 <main+0xc6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    70bc:	f2 e0       	ldi	r31, 0x02	; 2
    70be:	fa 95       	dec	r31
    70c0:	f1 f7       	brne	.-4      	; 0x70be <main+0xa0>
    70c2:	00 c0       	rjmp	.+0      	; 0x70c4 <main+0xa6>
	while (boot_state==0)
	{
		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
		{
			_delay_ms(0.001);
			boot_timer++;
    70c4:	01 96       	adiw	r24, 0x01	; 1
    70c6:	a1 1d       	adc	r26, r1
    70c8:	b1 1d       	adc	r27, r1

			if(boot_timer<50) PORTD |= (1<<PIND5); // 3x led AUSGANG,
    70ca:	82 33       	cpi	r24, 0x32	; 50
    70cc:	91 05       	cpc	r25, r1
    70ce:	a1 05       	cpc	r26, r1
    70d0:	b1 05       	cpc	r27, r1
    70d2:	10 f4       	brcc	.+4      	; 0x70d8 <main+0xba>
    70d4:	5d 9a       	sbi	0x0b, 5	; 11
    70d6:	09 c0       	rjmp	.+18     	; 0x70ea <main+0xcc>
			else PORTD &= ~(1<<PIND5);
    70d8:	5d 98       	cbi	0x0b, 5	; 11

			if(boot_timer>100) boot_timer=0;
    70da:	85 36       	cpi	r24, 0x65	; 101
    70dc:	91 05       	cpc	r25, r1
    70de:	a1 05       	cpc	r26, r1
    70e0:	b1 05       	cpc	r27, r1
    70e2:	18 f0       	brcs	.+6      	; 0x70ea <main+0xcc>
    70e4:	80 e0       	ldi	r24, 0x00	; 0
    70e6:	90 e0       	ldi	r25, 0x00	; 0
    70e8:	dc 01       	movw	r26, r24
}

//************************************************************************
static int	Serial_Available(void)
{
	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
    70ea:	20 91 c0 00 	lds	r18, 0x00C0
	seqNum++;
	PORTD |= (1<<PIND6); // 3x led AUSGANG,

	while (boot_state==0)
	{
		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
    70ee:	27 ff       	sbrs	r18, 7
    70f0:	e5 cf       	rjmp	.-54     	; 0x70bc <main+0x9e>
			}
		}
		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
	}

	PORTD |= (1<<PIND7); // 3x led AUSGANG,
    70f2:	5f 9a       	sbi	0x0b, 7	; 11
    70f4:	dd 24       	eor	r13, r13
    70f6:	d3 94       	inc	r13
    70f8:	aa 24       	eor	r10, r10
    70fa:	bb 24       	eor	r11, r11
    70fc:	ee 24       	eor	r14, r14
    70fe:	ff 24       	eor	r15, r15
						msgParseState = ST_START;
					}
					break;

				case ST_GET_DATA:
					msgBuffer[i++] = c;
    7100:	3e 01       	movw	r6, r28
    7102:	08 94       	sec
    7104:	61 1c       	adc	r6, r1
    7106:	71 1c       	adc	r7, r1

			case CMD_PROGRAM_FLASH_ISP:
			case CMD_PROGRAM_EEPROM_ISP:
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
				unsigned char *p = msgBuffer+10;
    7108:	0b e0       	ldi	r16, 0x0B	; 11
    710a:	20 2e       	mov	r2, r16
    710c:	31 2c       	mov	r3, r1
    710e:	2c 0e       	add	r2, r28
    7110:	3d 1e       	adc	r3, r29
					else
						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
				}
				else
				{
					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    7112:	19 e0       	ldi	r17, 0x09	; 9
    7114:	c1 2e       	mov	r12, r17
    7116:	87 01       	movw	r16, r14
    7118:	d3 c1       	rjmp	.+934    	; 0x74c0 <main+0x4a2>
/*
 * Read single byte from USART, block if no data available
 */
static unsigned char recchar(void)
{
	while(!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)));  // wait for data
    711a:	90 91 c0 00 	lds	r25, 0x00C0
    711e:	97 ff       	sbrs	r25, 7
    7120:	fc cf       	rjmp	.-8      	; 0x711a <main+0xfc>
	return UART_DATA_REG;
    7122:	40 91 c6 00 	lds	r20, 0x00C6
			 */
			msgParseState = ST_START;
			while ( msgParseState != ST_PROCESS )
			{
				c = recchar();
				switch (msgParseState)
    7126:	83 30       	cpi	r24, 0x03	; 3
    7128:	f9 f0       	breq	.+62     	; 0x7168 <main+0x14a>
    712a:	84 30       	cpi	r24, 0x04	; 4
    712c:	28 f4       	brcc	.+10     	; 0x7138 <main+0x11a>
    712e:	81 30       	cpi	r24, 0x01	; 1
    7130:	69 f0       	breq	.+26     	; 0x714c <main+0x12e>
    7132:	82 30       	cpi	r24, 0x02	; 2
    7134:	a0 f4       	brcc	.+40     	; 0x715e <main+0x140>
    7136:	07 c0       	rjmp	.+14     	; 0x7146 <main+0x128>
    7138:	85 30       	cpi	r24, 0x05	; 5
    713a:	29 f1       	breq	.+74     	; 0x7186 <main+0x168>
    713c:	85 30       	cpi	r24, 0x05	; 5
    713e:	d8 f0       	brcs	.+54     	; 0x7176 <main+0x158>
    7140:	86 30       	cpi	r24, 0x06	; 6
    7142:	59 f7       	brne	.-42     	; 0x711a <main+0xfc>
    7144:	2d c0       	rjmp	.+90     	; 0x71a0 <main+0x182>
				{
				case ST_START:
					if( c == MESSAGE_START )
    7146:	4b 31       	cpi	r20, 0x1B	; 27
    7148:	a9 f5       	brne	.+106    	; 0x71b4 <main+0x196>
    714a:	2e c0       	rjmp	.+92     	; 0x71a8 <main+0x18a>
						checksum = MESSAGE_START^0;
					}
					break;

				case ST_GET_SEQ_NUM:
					if ( (c == 1) || (c == seqNum) )
    714c:	41 30       	cpi	r20, 0x01	; 1
    714e:	19 f0       	breq	.+6      	; 0x7156 <main+0x138>
    7150:	4d 15       	cp	r20, r13
    7152:	09 f0       	breq	.+2      	; 0x7156 <main+0x138>
    7154:	b7 c1       	rjmp	.+878    	; 0x74c4 <main+0x4a6>
					{
						seqNum = c;
						msgParseState = ST_MSG_SIZE_1;
						checksum ^= c;
    7156:	54 26       	eor	r5, r20
 * Read single byte from USART, block if no data available
 */
static unsigned char recchar(void)
{
	while(!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)));  // wait for data
	return UART_DATA_REG;
    7158:	d4 2e       	mov	r13, r20

				case ST_GET_SEQ_NUM:
					if ( (c == 1) || (c == seqNum) )
					{
						seqNum = c;
						msgParseState = ST_MSG_SIZE_1;
    715a:	82 e0       	ldi	r24, 0x02	; 2
						checksum ^= c;
    715c:	de cf       	rjmp	.-68     	; 0x711a <main+0xfc>
						msgParseState = ST_START;
					}
					break;

				case ST_MSG_SIZE_1:
					msgLength = (unsigned int)c<<8;
    715e:	34 2f       	mov	r19, r20
    7160:	20 e0       	ldi	r18, 0x00	; 0
					msgParseState = ST_MSG_SIZE_2;
					checksum ^= c;
    7162:	54 26       	eor	r5, r20
					}
					break;

				case ST_MSG_SIZE_1:
					msgLength = (unsigned int)c<<8;
					msgParseState = ST_MSG_SIZE_2;
    7164:	83 e0       	ldi	r24, 0x03	; 3
					checksum ^= c;
					break;
    7166:	d9 cf       	rjmp	.-78     	; 0x711a <main+0xfc>

				case ST_MSG_SIZE_2:
					msgLength |= c;
    7168:	84 2f       	mov	r24, r20
    716a:	90 e0       	ldi	r25, 0x00	; 0
    716c:	28 2b       	or	r18, r24
    716e:	39 2b       	or	r19, r25
					msgParseState = ST_GET_TOKEN;
					checksum ^= c;
    7170:	54 26       	eor	r5, r20
					checksum ^= c;
					break;

				case ST_MSG_SIZE_2:
					msgLength |= c;
					msgParseState = ST_GET_TOKEN;
    7172:	84 e0       	ldi	r24, 0x04	; 4
					checksum ^= c;
					break;
    7174:	d2 cf       	rjmp	.-92     	; 0x711a <main+0xfc>

				case ST_GET_TOKEN:
					if ( c == TOKEN )
    7176:	4e 30       	cpi	r20, 0x0E	; 14
    7178:	09 f0       	breq	.+2      	; 0x717c <main+0x15e>
    717a:	a4 c1       	rjmp	.+840    	; 0x74c4 <main+0x4a6>
					{
						msgParseState = ST_GET_DATA;
						checksum ^= c;
    717c:	54 26       	eor	r5, r20
						i = 0;
    717e:	aa 24       	eor	r10, r10
    7180:	bb 24       	eor	r11, r11
					break;

				case ST_GET_TOKEN:
					if ( c == TOKEN )
					{
						msgParseState = ST_GET_DATA;
    7182:	85 e0       	ldi	r24, 0x05	; 5
    7184:	ca cf       	rjmp	.-108    	; 0x711a <main+0xfc>
						msgParseState = ST_START;
					}
					break;

				case ST_GET_DATA:
					msgBuffer[i++] = c;
    7186:	f3 01       	movw	r30, r6
    7188:	ea 0d       	add	r30, r10
    718a:	fb 1d       	adc	r31, r11
    718c:	40 83       	st	Z, r20
    718e:	08 94       	sec
    7190:	a1 1c       	adc	r10, r1
    7192:	b1 1c       	adc	r11, r1
					checksum ^= c;
    7194:	54 26       	eor	r5, r20
					if ( i == msgLength )
    7196:	a2 16       	cp	r10, r18
    7198:	b3 06       	cpc	r11, r19
    719a:	09 f0       	breq	.+2      	; 0x719e <main+0x180>
    719c:	be cf       	rjmp	.-132    	; 0x711a <main+0xfc>
    719e:	08 c0       	rjmp	.+16     	; 0x71b0 <main+0x192>
						msgParseState = ST_GET_CHECK;
					}
					break;

				case ST_GET_CHECK:
					if( c == checksum )
    71a0:	45 15       	cp	r20, r5
    71a2:	09 f0       	breq	.+2      	; 0x71a6 <main+0x188>
    71a4:	8f c1       	rjmp	.+798    	; 0x74c4 <main+0x4a6>
    71a6:	09 c0       	rjmp	.+18     	; 0x71ba <main+0x19c>
				{
				case ST_START:
					if( c == MESSAGE_START )
					{
						msgParseState = ST_GET_SEQ_NUM;
						checksum = MESSAGE_START^0;
    71a8:	bb e1       	ldi	r27, 0x1B	; 27
    71aa:	5b 2e       	mov	r5, r27
				switch (msgParseState)
				{
				case ST_START:
					if( c == MESSAGE_START )
					{
						msgParseState = ST_GET_SEQ_NUM;
    71ac:	81 e0       	ldi	r24, 0x01	; 1
    71ae:	b5 cf       	rjmp	.-150    	; 0x711a <main+0xfc>
				case ST_GET_DATA:
					msgBuffer[i++] = c;
					checksum ^= c;
					if ( i == msgLength )
					{
						msgParseState = ST_GET_CHECK;
    71b0:	86 e0       	ldi	r24, 0x06	; 6
    71b2:	b3 cf       	rjmp	.-154    	; 0x711a <main+0xfc>
		{
			/*
			 * Collect received bytes to a complete message
			 */
			msgParseState = ST_START;
			while ( msgParseState != ST_PROCESS )
    71b4:	87 30       	cpi	r24, 0x07	; 7
    71b6:	09 f0       	breq	.+2      	; 0x71ba <main+0x19c>
    71b8:	b0 cf       	rjmp	.-160    	; 0x711a <main+0xfc>

			/*
			 * Now process the STK500 commands, see Atmel Appnote AVR068
			 */

			switch (msgBuffer[0])
    71ba:	49 81       	ldd	r20, Y+1	; 0x01
    71bc:	43 31       	cpi	r20, 0x13	; 19
    71be:	09 f4       	brne	.+2      	; 0x71c2 <main+0x1a4>
    71c0:	b6 c0       	rjmp	.+364    	; 0x732e <main+0x310>
    71c2:	44 31       	cpi	r20, 0x14	; 20
    71c4:	98 f4       	brcc	.+38     	; 0x71ec <main+0x1ce>
    71c6:	46 30       	cpi	r20, 0x06	; 6
    71c8:	09 f4       	brne	.+2      	; 0x71cc <main+0x1ae>
    71ca:	99 c0       	rjmp	.+306    	; 0x72fe <main+0x2e0>
    71cc:	47 30       	cpi	r20, 0x07	; 7
    71ce:	50 f4       	brcc	.+20     	; 0x71e4 <main+0x1c6>
    71d0:	42 30       	cpi	r20, 0x02	; 2
    71d2:	09 f4       	brne	.+2      	; 0x71d6 <main+0x1b8>
    71d4:	02 c1       	rjmp	.+516    	; 0x73da <main+0x3bc>
    71d6:	43 30       	cpi	r20, 0x03	; 3
    71d8:	09 f4       	brne	.+2      	; 0x71dc <main+0x1be>
    71da:	51 c0       	rjmp	.+162    	; 0x727e <main+0x260>
    71dc:	41 30       	cpi	r20, 0x01	; 1
    71de:	09 f0       	breq	.+2      	; 0x71e2 <main+0x1c4>
    71e0:	43 c1       	rjmp	.+646    	; 0x7468 <main+0x44a>
    71e2:	36 c0       	rjmp	.+108    	; 0x7250 <main+0x232>
    71e4:	40 31       	cpi	r20, 0x10	; 16
    71e6:	08 f4       	brcc	.+2      	; 0x71ea <main+0x1cc>
    71e8:	3f c1       	rjmp	.+638    	; 0x7468 <main+0x44a>
    71ea:	f7 c0       	rjmp	.+494    	; 0x73da <main+0x3bc>
    71ec:	48 31       	cpi	r20, 0x18	; 24
    71ee:	09 f4       	brne	.+2      	; 0x71f2 <main+0x1d4>
    71f0:	6d c0       	rjmp	.+218    	; 0x72cc <main+0x2ae>
    71f2:	49 31       	cpi	r20, 0x19	; 25
    71f4:	50 f4       	brcc	.+20     	; 0x720a <main+0x1ec>
    71f6:	45 31       	cpi	r20, 0x15	; 21
    71f8:	09 f4       	brne	.+2      	; 0x71fc <main+0x1de>
    71fa:	99 c0       	rjmp	.+306    	; 0x732e <main+0x310>
    71fc:	45 31       	cpi	r20, 0x15	; 21
    71fe:	08 f4       	brcc	.+2      	; 0x7202 <main+0x1e4>
    7200:	ee c0       	rjmp	.+476    	; 0x73de <main+0x3c0>
    7202:	46 31       	cpi	r20, 0x16	; 22
    7204:	09 f0       	breq	.+2      	; 0x7208 <main+0x1ea>
    7206:	30 c1       	rjmp	.+608    	; 0x7468 <main+0x44a>
    7208:	ea c0       	rjmp	.+468    	; 0x73de <main+0x3c0>
    720a:	4b 31       	cpi	r20, 0x1B	; 27
    720c:	09 f4       	brne	.+2      	; 0x7210 <main+0x1f2>
    720e:	47 c0       	rjmp	.+142    	; 0x729e <main+0x280>
    7210:	4d 31       	cpi	r20, 0x1D	; 29
    7212:	21 f0       	breq	.+8      	; 0x721c <main+0x1fe>
    7214:	4a 31       	cpi	r20, 0x1A	; 26
    7216:	09 f0       	breq	.+2      	; 0x721a <main+0x1fc>
    7218:	27 c1       	rjmp	.+590    	; 0x7468 <main+0x44a>
    721a:	4c c0       	rjmp	.+152    	; 0x72b4 <main+0x296>
			case CMD_SPI_MULTI:
			{
				unsigned char answerByte = 0;

				// only Read Signature Bytes implemented, return dummy value for other instructions
				if ( msgBuffer[4]== 0x30 )
    721c:	9d 81       	ldd	r25, Y+5	; 0x05
    721e:	90 33       	cpi	r25, 0x30	; 48
    7220:	39 f4       	brne	.+14     	; 0x7230 <main+0x212>
				{
					unsigned char signatureIndex = msgBuffer[6];
    7222:	8f 81       	ldd	r24, Y+7	; 0x07

					if ( signatureIndex == 0 )
    7224:	88 23       	and	r24, r24
    7226:	31 f0       	breq	.+12     	; 0x7234 <main+0x216>
						answerByte = (SIGNATURE_BYTES >>16) & 0x000000FF;
					else if ( signatureIndex == 1 )
    7228:	81 30       	cpi	r24, 0x01	; 1
    722a:	31 f4       	brne	.+12     	; 0x7238 <main+0x21a>
						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
    722c:	85 e9       	ldi	r24, 0x95	; 149
    722e:	05 c0       	rjmp	.+10     	; 0x723a <main+0x21c>

			switch (msgBuffer[0])
			{
			case CMD_SPI_MULTI:
			{
				unsigned char answerByte = 0;
    7230:	80 e0       	ldi	r24, 0x00	; 0
    7232:	03 c0       	rjmp	.+6      	; 0x723a <main+0x21c>
				if ( msgBuffer[4]== 0x30 )
				{
					unsigned char signatureIndex = msgBuffer[6];

					if ( signatureIndex == 0 )
						answerByte = (SIGNATURE_BYTES >>16) & 0x000000FF;
    7234:	8e e1       	ldi	r24, 0x1E	; 30
    7236:	01 c0       	rjmp	.+2      	; 0x723a <main+0x21c>
					else if ( signatureIndex == 1 )
						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
					else
						answerByte = SIGNATURE_BYTES & 0x000000FF;
    7238:	8f e0       	ldi	r24, 0x0F	; 15
				}
				msgLength = 7;
				msgBuffer[1] = STATUS_CMD_OK;
    723a:	1a 82       	std	Y+2, r1	; 0x02
				msgBuffer[2] = 0;
    723c:	1b 82       	std	Y+3, r1	; 0x03
				msgBuffer[3] = msgBuffer[4];  // Instruction Byte 1
    723e:	9c 83       	std	Y+4, r25	; 0x04
				msgBuffer[4] = msgBuffer[5];  // Instruction Byte 2
    7240:	9e 81       	ldd	r25, Y+6	; 0x06
    7242:	9d 83       	std	Y+5, r25	; 0x05
				msgBuffer[5] = answerByte;
    7244:	8e 83       	std	Y+6, r24	; 0x06
				msgBuffer[6] = STATUS_CMD_OK;
    7246:	1f 82       	std	Y+7, r1	; 0x07
					else if ( signatureIndex == 1 )
						answerByte = (SIGNATURE_BYTES >> 8) & 0x000000FF;
					else
						answerByte = SIGNATURE_BYTES & 0x000000FF;
				}
				msgLength = 7;
    7248:	a7 e0       	ldi	r26, 0x07	; 7
    724a:	ea 2e       	mov	r14, r26
    724c:	f1 2c       	mov	r15, r1
				msgBuffer[3] = msgBuffer[4];  // Instruction Byte 1
				msgBuffer[4] = msgBuffer[5];  // Instruction Byte 2
				msgBuffer[5] = answerByte;
				msgBuffer[6] = STATUS_CMD_OK;
			}
			break;
    724e:	11 c1       	rjmp	.+546    	; 0x7472 <main+0x454>
			case CMD_SIGN_ON:
				msgLength = 11;
				msgBuffer[1]  = STATUS_CMD_OK;
    7250:	1a 82       	std	Y+2, r1	; 0x02
				msgBuffer[2]  = 8;
    7252:	88 e0       	ldi	r24, 0x08	; 8
    7254:	8b 83       	std	Y+3, r24	; 0x03
				msgBuffer[3]  = 'A';
    7256:	81 e4       	ldi	r24, 0x41	; 65
    7258:	8c 83       	std	Y+4, r24	; 0x04
				msgBuffer[4]  = 'V';
    725a:	86 e5       	ldi	r24, 0x56	; 86
    725c:	8d 83       	std	Y+5, r24	; 0x05
				msgBuffer[5]  = 'R';
    725e:	82 e5       	ldi	r24, 0x52	; 82
    7260:	8e 83       	std	Y+6, r24	; 0x06
				msgBuffer[6]  = 'I';
    7262:	89 e4       	ldi	r24, 0x49	; 73
    7264:	8f 83       	std	Y+7, r24	; 0x07
				msgBuffer[7]  = 'S';
    7266:	83 e5       	ldi	r24, 0x53	; 83
    7268:	88 87       	std	Y+8, r24	; 0x08
				msgBuffer[8]  = 'P';
    726a:	80 e5       	ldi	r24, 0x50	; 80
    726c:	89 87       	std	Y+9, r24	; 0x09
				msgBuffer[9]  = '_';
    726e:	8f e5       	ldi	r24, 0x5F	; 95
    7270:	8a 87       	std	Y+10, r24	; 0x0a
				msgBuffer[10] = '2';
    7272:	82 e3       	ldi	r24, 0x32	; 50
    7274:	8b 87       	std	Y+11, r24	; 0x0b
				msgBuffer[5] = answerByte;
				msgBuffer[6] = STATUS_CMD_OK;
			}
			break;
			case CMD_SIGN_ON:
				msgLength = 11;
    7276:	fb e0       	ldi	r31, 0x0B	; 11
    7278:	ef 2e       	mov	r14, r31
    727a:	f1 2c       	mov	r15, r1
				msgBuffer[6]  = 'I';
				msgBuffer[7]  = 'S';
				msgBuffer[8]  = 'P';
				msgBuffer[9]  = '_';
				msgBuffer[10] = '2';
				break;
    727c:	fa c0       	rjmp	.+500    	; 0x7472 <main+0x454>

			case CMD_GET_PARAMETER:
			{
				unsigned char value;

				switch(msgBuffer[1])
    727e:	ea 81       	ldd	r30, Y+2	; 0x02
    7280:	e0 58       	subi	r30, 0x80	; 128
    7282:	e3 31       	cpi	r30, 0x13	; 19
    7284:	28 f4       	brcc	.+10     	; 0x7290 <main+0x272>
    7286:	f0 e0       	ldi	r31, 0x00	; 0
    7288:	e0 50       	subi	r30, 0x00	; 0
    728a:	ff 4f       	sbci	r31, 0xFF	; 255
    728c:	80 81       	ld	r24, Z
    728e:	01 c0       	rjmp	.+2      	; 0x7292 <main+0x274>
    7290:	80 e0       	ldi	r24, 0x00	; 0
				default:
					value = 0;
					break;
				}
				msgLength = 3;
				msgBuffer[1] = STATUS_CMD_OK;
    7292:	1a 82       	std	Y+2, r1	; 0x02
				msgBuffer[2] = value;
    7294:	8b 83       	std	Y+3, r24	; 0x03
					break;
				default:
					value = 0;
					break;
				}
				msgLength = 3;
    7296:	e3 e0       	ldi	r30, 0x03	; 3
    7298:	ee 2e       	mov	r14, r30
    729a:	f1 2c       	mov	r15, r1
				msgBuffer[1] = STATUS_CMD_OK;
				msgBuffer[2] = value;
			}
			break;
    729c:	ea c0       	rjmp	.+468    	; 0x7472 <main+0x454>
				msgBuffer[1] = STATUS_CMD_OK;
				break;

			case CMD_READ_SIGNATURE_ISP:
			{
				unsigned char signatureIndex = msgBuffer[4];
    729e:	8d 81       	ldd	r24, Y+5	; 0x05
				unsigned char signature;

				if ( signatureIndex == 0 )
    72a0:	88 23       	and	r24, r24
    72a2:	21 f0       	breq	.+8      	; 0x72ac <main+0x28e>
					signature = (SIGNATURE_BYTES >>16) & 0x000000FF;
				else if ( signatureIndex == 1 )
    72a4:	81 30       	cpi	r24, 0x01	; 1
    72a6:	21 f4       	brne	.+8      	; 0x72b0 <main+0x292>
					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
    72a8:	85 e9       	ldi	r24, 0x95	; 149
    72aa:	27 c0       	rjmp	.+78     	; 0x72fa <main+0x2dc>
			{
				unsigned char signatureIndex = msgBuffer[4];
				unsigned char signature;

				if ( signatureIndex == 0 )
					signature = (SIGNATURE_BYTES >>16) & 0x000000FF;
    72ac:	8e e1       	ldi	r24, 0x1E	; 30
    72ae:	25 c0       	rjmp	.+74     	; 0x72fa <main+0x2dc>
				else if ( signatureIndex == 1 )
					signature = (SIGNATURE_BYTES >> 8) & 0x000000FF;
				else
					signature = SIGNATURE_BYTES & 0x000000FF;
    72b0:	8f e0       	ldi	r24, 0x0F	; 15
    72b2:	23 c0       	rjmp	.+70     	; 0x72fa <main+0x2dc>
			}
			break;

			case CMD_READ_LOCK_ISP:
				msgLength = 4;
				msgBuffer[1] = STATUS_CMD_OK;
    72b4:	1a 82       	std	Y+2, r1	; 0x02
				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
    72b6:	e1 e0       	ldi	r30, 0x01	; 1
    72b8:	f0 e0       	ldi	r31, 0x00	; 0
    72ba:	c0 92 57 00 	sts	0x0057, r12
    72be:	84 91       	lpm	r24, Z+
    72c0:	8b 83       	std	Y+3, r24	; 0x03
				msgBuffer[3] = STATUS_CMD_OK;
    72c2:	1c 82       	std	Y+4, r1	; 0x04
				msgBuffer[3] = STATUS_CMD_OK;
			}
			break;

			case CMD_READ_LOCK_ISP:
				msgLength = 4;
    72c4:	74 e0       	ldi	r23, 0x04	; 4
    72c6:	e7 2e       	mov	r14, r23
    72c8:	f1 2c       	mov	r15, r1
				msgBuffer[1] = STATUS_CMD_OK;
				msgBuffer[2] = boot_lock_fuse_bits_get( GET_LOCK_BITS );
				msgBuffer[3] = STATUS_CMD_OK;
				break;
    72ca:	d3 c0       	rjmp	.+422    	; 0x7472 <main+0x454>

			case CMD_READ_FUSE_ISP:
			{
				unsigned char fuseBits;

				if ( msgBuffer[2] == 0x50 )
    72cc:	8b 81       	ldd	r24, Y+3	; 0x03
    72ce:	80 35       	cpi	r24, 0x50	; 80
    72d0:	79 f4       	brne	.+30     	; 0x72f0 <main+0x2d2>
				{
					if ( msgBuffer[3] == 0x08 )
    72d2:	8c 81       	ldd	r24, Y+4	; 0x04
    72d4:	88 30       	cpi	r24, 0x08	; 8
    72d6:	31 f4       	brne	.+12     	; 0x72e4 <main+0x2c6>
						fuseBits = boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
    72d8:	e2 e0       	ldi	r30, 0x02	; 2
    72da:	f0 e0       	ldi	r31, 0x00	; 0
    72dc:	c0 92 57 00 	sts	0x0057, r12
    72e0:	84 91       	lpm	r24, Z+
    72e2:	0b c0       	rjmp	.+22     	; 0x72fa <main+0x2dc>
					else
						fuseBits = boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
    72e4:	e0 e0       	ldi	r30, 0x00	; 0
    72e6:	f0 e0       	ldi	r31, 0x00	; 0
    72e8:	c0 92 57 00 	sts	0x0057, r12
    72ec:	84 91       	lpm	r24, Z+
    72ee:	05 c0       	rjmp	.+10     	; 0x72fa <main+0x2dc>
				}
				else
				{
					fuseBits = boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
    72f0:	e3 e0       	ldi	r30, 0x03	; 3
    72f2:	f0 e0       	ldi	r31, 0x00	; 0
    72f4:	c0 92 57 00 	sts	0x0057, r12
    72f8:	84 91       	lpm	r24, Z+
				}
				msgLength = 4;
				msgBuffer[1] = STATUS_CMD_OK;
    72fa:	1a 82       	std	Y+2, r1	; 0x02
    72fc:	e1 cf       	rjmp	.-62     	; 0x72c0 <main+0x2a2>
				msgLength = 2;
				msgBuffer[1] = STATUS_CMD_OK;
				break;

			case CMD_LOAD_ADDRESS:
				address = ( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;  //convert word to byte address
    72fe:	2c 81       	ldd	r18, Y+4	; 0x04
    7300:	c1 5e       	subi	r28, 0xE1	; 225
    7302:	de 4f       	sbci	r29, 0xFE	; 254
    7304:	28 83       	st	Y, r18
    7306:	cf 51       	subi	r28, 0x1F	; 31
    7308:	d1 40       	sbci	r29, 0x01	; 1
    730a:	c2 5e       	subi	r28, 0xE2	; 226
    730c:	de 4f       	sbci	r29, 0xFE	; 254
    730e:	18 82       	st	Y, r1
    7310:	ce 51       	subi	r28, 0x1E	; 30
    7312:	d1 40       	sbci	r29, 0x01	; 1
    7314:	0d 81       	ldd	r16, Y+5	; 0x05
    7316:	10 e0       	ldi	r17, 0x00	; 0
    7318:	c2 5e       	subi	r28, 0xE2	; 226
    731a:	de 4f       	sbci	r29, 0xFE	; 254
    731c:	88 81       	ld	r24, Y
    731e:	99 81       	ldd	r25, Y+1	; 0x01
    7320:	ce 51       	subi	r28, 0x1E	; 30
    7322:	d1 40       	sbci	r29, 0x01	; 1
    7324:	08 2b       	or	r16, r24
    7326:	19 2b       	or	r17, r25
    7328:	00 0f       	add	r16, r16
    732a:	11 1f       	adc	r17, r17
    732c:	56 c0       	rjmp	.+172    	; 0x73da <main+0x3bc>
				break;

			case CMD_PROGRAM_FLASH_ISP:
			case CMD_PROGRAM_EEPROM_ISP:
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    732e:	9a 81       	ldd	r25, Y+2	; 0x02
    7330:	cf 5d       	subi	r28, 0xDF	; 223
    7332:	de 4f       	sbci	r29, 0xFE	; 254
    7334:	98 83       	st	Y, r25
    7336:	c1 52       	subi	r28, 0x21	; 33
    7338:	d1 40       	sbci	r29, 0x01	; 1
    733a:	c0 5e       	subi	r28, 0xE0	; 224
    733c:	de 4f       	sbci	r29, 0xFE	; 254
    733e:	18 82       	st	Y, r1
    7340:	c0 52       	subi	r28, 0x20	; 32
    7342:	d1 40       	sbci	r29, 0x01	; 1
    7344:	8b 81       	ldd	r24, Y+3	; 0x03
    7346:	90 e0       	ldi	r25, 0x00	; 0
    7348:	c0 5e       	subi	r28, 0xE0	; 224
    734a:	de 4f       	sbci	r29, 0xFE	; 254
    734c:	e8 81       	ld	r30, Y
    734e:	f9 81       	ldd	r31, Y+1	; 0x01
    7350:	c0 52       	subi	r28, 0x20	; 32
    7352:	d1 40       	sbci	r29, 0x01	; 1
    7354:	8e 2b       	or	r24, r30
    7356:	9f 2b       	or	r25, r31
				unsigned int  data;
				unsigned char highByte, lowByte;
				address_t     tempaddress = address;


				if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
    7358:	43 31       	cpi	r20, 0x13	; 19
    735a:	09 f0       	breq	.+2      	; 0x735e <main+0x340>
    735c:	2c c0       	rjmp	.+88     	; 0x73b6 <main+0x398>
				{
					// erase only main section (bootloader protection)
					if  (  eraseAddress < APP_END )
					{
						// If we are in RWW section, immediately start page erase
						__boot_page_erase_short((uint16_t)(void*)address);
    735e:	23 e0       	ldi	r18, 0x03	; 3
    7360:	f8 01       	movw	r30, r16
    7362:	27 bf       	out	0x37, r18	; 55
    7364:	e8 95       	spm
						//						boot_page_erase(eraseAddress);	// Perform page erase
						//						boot_spm_busy_wait();		// Wait until the memory is erased.
						//						eraseAddress += SPM_PAGESIZE;    // point to next page to be erase
						msgLength = 2;
						msgBuffer[1] = STATUS_CMD_OK;
    7366:	1a 82       	std	Y+2, r1	; 0x02
					} else {
						msgLength = 2;
						msgBuffer[1] = STATUS_CMD_FAILED;
					}

					do{}while(((SPMCSR)& (1<<SELFPRGEN)));
    7368:	07 b6       	in	r0, 0x37	; 55
    736a:	00 fc       	sbrc	r0, 0
    736c:	fd cf       	rjmp	.-6      	; 0x7368 <main+0x34a>
    736e:	f8 01       	movw	r30, r16


					// Copy buffer into programming buffer
					uint8_t *bufPtr=msgBuffer+10;
    7370:	d1 01       	movw	r26, r2
					uint16_t addrPtr = (uint16_t)(void*)address;
					do {
						uint16_t a;
						a = *bufPtr++;
    7372:	2c 91       	ld	r18, X
    7374:	30 e0       	ldi	r19, 0x00	; 0
						a |= (*bufPtr++) << 8;
    7376:	11 96       	adiw	r26, 0x01	; 1
    7378:	5c 91       	ld	r21, X
    737a:	11 97       	sbiw	r26, 0x01	; 1
    737c:	40 e0       	ldi	r20, 0x00	; 0
    737e:	24 2b       	or	r18, r20
    7380:	35 2b       	or	r19, r21
	return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    7382:	12 96       	adiw	r26, 0x02	; 2
					uint16_t addrPtr = (uint16_t)(void*)address;
					do {
						uint16_t a;
						a = *bufPtr++;
						a |= (*bufPtr++) << 8;
						__boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7384:	61 e0       	ldi	r22, 0x01	; 1
    7386:	09 01       	movw	r0, r18
    7388:	67 bf       	out	0x37, r22	; 55
    738a:	e8 95       	spm
    738c:	11 24       	eor	r1, r1
						addrPtr += 2;
    738e:	32 96       	adiw	r30, 0x02	; 2
						size -= 2;			// Reduce number of bytes to write by two
    7390:	02 97       	sbiw	r24, 0x02	; 2
					} while (size);
    7392:	79 f7       	brne	.-34     	; 0x7372 <main+0x354>
    7394:	cc 5d       	subi	r28, 0xDC	; 220
    7396:	de 4f       	sbci	r29, 0xFE	; 254
    7398:	59 83       	std	Y+1, r21	; 0x01
    739a:	48 83       	st	Y, r20
    739c:	c4 52       	subi	r28, 0x24	; 36
    739e:	d1 40       	sbci	r29, 0x01	; 1

					// Write from programming buffer
					__boot_page_write_short((uint16_t)(void*)address);
    73a0:	25 e0       	ldi	r18, 0x05	; 5
    73a2:	f8 01       	movw	r30, r16
    73a4:	27 bf       	out	0x37, r18	; 55
    73a6:	e8 95       	spm

					do{}while(((SPMCSR)& (1<<SELFPRGEN)));
    73a8:	07 b6       	in	r0, 0x37	; 55
    73aa:	00 fc       	sbrc	r0, 0
    73ac:	fd cf       	rjmp	.-6      	; 0x73a8 <main+0x38a>

#if defined(RWWSRE)
					// Reenable read access to flash
					boot_rww_enable();
    73ae:	31 e1       	ldi	r19, 0x11	; 17
    73b0:	37 bf       	out	0x37, r19	; 55
    73b2:	e8 95       	spm
    73b4:	5b c0       	rjmp	.+182    	; 0x746c <main+0x44e>
				unsigned int  data;
				unsigned char highByte, lowByte;
				address_t     tempaddress = address;


				if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
    73b6:	ac 01       	movw	r20, r24
    73b8:	98 01       	movw	r18, r16

			case CMD_PROGRAM_FLASH_ISP:
			case CMD_PROGRAM_EEPROM_ISP:
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
				unsigned char *p = msgBuffer+10;
    73ba:	f1 01       	movw	r30, r2
				}
				else
				{
					/* write EEPROM */
					do {
						EEARL = address;			// Setup EEPROM address
    73bc:	21 bd       	out	0x21, r18	; 33
						EEARH = (address >> 8);
    73be:	32 bd       	out	0x22, r19	; 34
						address++;					// Select next EEPROM byte
    73c0:	2f 5f       	subi	r18, 0xFF	; 255
    73c2:	3f 4f       	sbci	r19, 0xFF	; 255

						EEDR= *p++;				    // get byte from buffer
    73c4:	61 91       	ld	r22, Z+
    73c6:	60 bd       	out	0x20, r22	; 32
						EECR |= (1<<EEMWE);			// Write data into EEPROM
    73c8:	fa 9a       	sbi	0x1f, 2	; 31
						EECR |= (1<<EEWE);
    73ca:	f9 9a       	sbi	0x1f, 1	; 31

						while (EECR & (1<<EEWE));	// Wait for write operation to finish
    73cc:	f9 99       	sbic	0x1f, 1	; 31
    73ce:	fe cf       	rjmp	.-4      	; 0x73cc <main+0x3ae>
						size--;						// Decrease number of bytes to write
    73d0:	41 50       	subi	r20, 0x01	; 1
    73d2:	50 40       	sbci	r21, 0x00	; 0
					} while(size);					// Loop until all bytes written
    73d4:	99 f7       	brne	.-26     	; 0x73bc <main+0x39e>
    73d6:	08 0f       	add	r16, r24
    73d8:	19 1f       	adc	r17, r25
					msgLength = 2;
					msgBuffer[1] = STATUS_CMD_OK;
    73da:	1a 82       	std	Y+2, r1	; 0x02
    73dc:	47 c0       	rjmp	.+142    	; 0x746c <main+0x44e>
			break;

			case CMD_READ_FLASH_ISP:
			case CMD_READ_EEPROM_ISP:
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
    73de:	6a 81       	ldd	r22, Y+2	; 0x02
    73e0:	cd 5d       	subi	r28, 0xDD	; 221
    73e2:	de 4f       	sbci	r29, 0xFE	; 254
    73e4:	68 83       	st	Y, r22
    73e6:	c3 52       	subi	r28, 0x23	; 35
    73e8:	d1 40       	sbci	r29, 0x01	; 1
    73ea:	ce 5d       	subi	r28, 0xDE	; 222
    73ec:	de 4f       	sbci	r29, 0xFE	; 254
    73ee:	18 82       	st	Y, r1
    73f0:	c2 52       	subi	r28, 0x22	; 34
    73f2:	d1 40       	sbci	r29, 0x01	; 1
    73f4:	2b 81       	ldd	r18, Y+3	; 0x03
    73f6:	30 e0       	ldi	r19, 0x00	; 0
    73f8:	ce 5d       	subi	r28, 0xDE	; 222
    73fa:	de 4f       	sbci	r29, 0xFE	; 254
    73fc:	88 81       	ld	r24, Y
    73fe:	99 81       	ldd	r25, Y+1	; 0x01
    7400:	c2 52       	subi	r28, 0x22	; 34
    7402:	d1 40       	sbci	r29, 0x01	; 1
    7404:	28 2b       	or	r18, r24
    7406:	39 2b       	or	r19, r25
				unsigned char *p = msgBuffer+1;
				msgLength = size+3;
    7408:	53 e0       	ldi	r21, 0x03	; 3
    740a:	e5 2e       	mov	r14, r21
    740c:	f1 2c       	mov	r15, r1
    740e:	e2 0e       	add	r14, r18
    7410:	f3 1e       	adc	r15, r19

				*p++ = STATUS_CMD_OK;
    7412:	1a 82       	std	Y+2, r1	; 0x02
				if (msgBuffer[0] == CMD_READ_FLASH_ISP )
    7414:	44 31       	cpi	r20, 0x14	; 20
    7416:	81 f4       	brne	.+32     	; 0x7438 <main+0x41a>
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
				unsigned char *p = msgBuffer+1;
				msgLength = size+3;

				*p++ = STATUS_CMD_OK;
    7418:	de 01       	movw	r26, r28
    741a:	13 96       	adiw	r26, 0x03	; 3
					// Read FLASH
					do {
#if defined(RAMPZ)
						data = pgm_read_word_far(address);
#else
						data = pgm_read_word_near(address);
    741c:	f8 01       	movw	r30, r16
    741e:	85 91       	lpm	r24, Z+
    7420:	94 91       	lpm	r25, Z+
#endif
						*p++ = (unsigned char)data;         //LSB
    7422:	8c 93       	st	X, r24
						*p++ = (unsigned char)(data >> 8);	//MSB
    7424:	11 96       	adiw	r26, 0x01	; 1
    7426:	9c 93       	st	X, r25
    7428:	11 97       	sbiw	r26, 0x01	; 1
	return UART_DATA_REG;
}


int main(void) __attribute__ ((OS_main));
int main(void)
    742a:	12 96       	adiw	r26, 0x02	; 2
#else
						data = pgm_read_word_near(address);
#endif
						*p++ = (unsigned char)data;         //LSB
						*p++ = (unsigned char)(data >> 8);	//MSB
						address    += 2;  	 // Select next word in memory
    742c:	0e 5f       	subi	r16, 0xFE	; 254
    742e:	1f 4f       	sbci	r17, 0xFF	; 255
						size -= 2;
    7430:	22 50       	subi	r18, 0x02	; 2
    7432:	30 40       	sbci	r19, 0x00	; 0
					}while (size);
    7434:	99 f7       	brne	.-26     	; 0x741c <main+0x3fe>
    7436:	16 c0       	rjmp	.+44     	; 0x7464 <main+0x446>
			{
				unsigned int  size = (((unsigned int)msgBuffer[1])<<8) | msgBuffer[2];
				unsigned char *p = msgBuffer+1;
				msgLength = size+3;

				*p++ = STATUS_CMD_OK;
    7438:	ce 01       	movw	r24, r28
    743a:	03 96       	adiw	r24, 0x03	; 3
    743c:	e8 2f       	mov	r30, r24
    743e:	69 2f       	mov	r22, r25
				if (msgBuffer[0] == CMD_READ_FLASH_ISP )
    7440:	c9 01       	movw	r24, r18
    7442:	a8 01       	movw	r20, r16
				}
				else
				{
					/* Read EEPROM */
					do {
						EEARL = address;			// Setup EEPROM address
    7444:	41 bd       	out	0x21, r20	; 33
						EEARH = ((address >> 8));
    7446:	52 bd       	out	0x22, r21	; 34
						address++;					// Select next EEPROM byte
    7448:	4f 5f       	subi	r20, 0xFF	; 255
    744a:	5f 4f       	sbci	r21, 0xFF	; 255
						EECR |= (1<<EERE);			// Read EEPROM
    744c:	f8 9a       	sbi	0x1f, 0	; 31
						*p++ = EEDR;				// Send EEPROM data
    744e:	70 b5       	in	r23, 0x20	; 32
    7450:	ae 2f       	mov	r26, r30
    7452:	b6 2f       	mov	r27, r22
    7454:	7d 93       	st	X+, r23
    7456:	bd 01       	movw	r22, r26
    7458:	ea 2f       	mov	r30, r26
    745a:	67 2f       	mov	r22, r23
						size--;
    745c:	01 97       	sbiw	r24, 0x01	; 1
					}while(size);
    745e:	91 f7       	brne	.-28     	; 0x7444 <main+0x426>
    7460:	02 0f       	add	r16, r18
    7462:	13 1f       	adc	r17, r19
				}
				*p++ = STATUS_CMD_OK;
    7464:	1c 92       	st	X, r1
			}
			break;
    7466:	05 c0       	rjmp	.+10     	; 0x7472 <main+0x454>

			default:
				msgLength = 2;
				msgBuffer[1] = STATUS_CMD_FAILED;
    7468:	90 ec       	ldi	r25, 0xC0	; 192
    746a:	9a 83       	std	Y+2, r25	; 0x02
				*p++ = STATUS_CMD_OK;
			}
			break;

			default:
				msgLength = 2;
    746c:	92 e0       	ldi	r25, 0x02	; 2
    746e:	e9 2e       	mov	r14, r25
    7470:	f1 2c       	mov	r15, r1
			}

			/*
			 * Now send answer message back
			 */
			sendchar(MESSAGE_START);
    7472:	8b e1       	ldi	r24, 0x1B	; 27
    7474:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			checksum = MESSAGE_START^0;

			sendchar(seqNum);
    7478:	8d 2d       	mov	r24, r13
    747a:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			checksum ^= seqNum;

			c = ((msgLength>>8)&0xFF);
			sendchar(c);
    747e:	8f 2d       	mov	r24, r15
    7480:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			checksum ^= c;

			c = msgLength&0x00FF;
			sendchar(c);
    7484:	8e 2d       	mov	r24, r14
    7486:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			checksum ^= c;

			sendchar(TOKEN);
    748a:	8e e0       	ldi	r24, 0x0E	; 14
    748c:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			sendchar(seqNum);
			checksum ^= seqNum;

			c = ((msgLength>>8)&0xFF);
			sendchar(c);
			checksum ^= c;
    7490:	85 e1       	ldi	r24, 0x15	; 21
    7492:	58 2e       	mov	r5, r24
    7494:	5d 24       	eor	r5, r13

			c = msgLength&0x00FF;
			sendchar(c);
			checksum ^= c;
    7496:	5e 24       	eor	r5, r14

			sendchar(TOKEN);
			checksum ^= TOKEN;
    7498:	5f 24       	eor	r5, r15

			p = msgBuffer;
    749a:	43 01       	movw	r8, r6
			while ( msgLength )
    749c:	0a c0       	rjmp	.+20     	; 0x74b2 <main+0x494>
			{
				c = *p++;
    749e:	f4 01       	movw	r30, r8
    74a0:	41 90       	ld	r4, Z+
    74a2:	4f 01       	movw	r8, r30
				sendchar(c);
    74a4:	84 2d       	mov	r24, r4
    74a6:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
				checksum ^=c;
    74aa:	54 24       	eor	r5, r4
				msgLength--;
    74ac:	08 94       	sec
    74ae:	e1 08       	sbc	r14, r1
    74b0:	f1 08       	sbc	r15, r1

			sendchar(TOKEN);
			checksum ^= TOKEN;

			p = msgBuffer;
			while ( msgLength )
    74b2:	e1 14       	cp	r14, r1
    74b4:	f1 04       	cpc	r15, r1
    74b6:	99 f7       	brne	.-26     	; 0x749e <main+0x480>
				c = *p++;
				sendchar(c);
				checksum ^=c;
				msgLength--;
			}
			sendchar(checksum);
    74b8:	85 2d       	mov	r24, r5
    74ba:	0e 94 08 38 	call	0x7010	; 0x7010 <sendchar>
			seqNum++;
    74be:	d3 94       	inc	r13
		checksum ^=c;
		msgLength--;
	}
	sendchar(checksum);
	seqNum++;
	PORTD |= (1<<PIND6); // 3x led AUSGANG,
    74c0:	20 e0       	ldi	r18, 0x00	; 0
    74c2:	30 e0       	ldi	r19, 0x00	; 0
    74c4:	80 e0       	ldi	r24, 0x00	; 0
    74c6:	29 ce       	rjmp	.-942    	; 0x711a <main+0xfc>
